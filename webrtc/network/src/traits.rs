//! RTP Packetizer and Depacketizer traits
//!
//! This module defines the core abstractions for RTP packetization and depacketization.
//! These traits allow for codec-agnostic handling of RTP packet generation and reconstruction.

use crate::codec::rtp::RtpPacket;

/// Trait for RTP packetization of codec-specific data
///
/// Implementors of this trait convert encoded media data into RTP packets
/// according to codec-specific payload format specifications (RFC 6184 for H.264,
/// RFC 7741 for VP8, etc.).
///
/// # Responsibilities
///
/// - Fragment large payloads according to MTU constraints
/// - Add codec-specific headers (e.g., FU-A indicators for H.264)
/// - Manage RTP sequence numbers and timestamps
/// - Set marker bit for frame boundaries
pub trait RtpPacketizer {
    /// Packetize encoded media data into RTP packets
    ///
    /// Converts a single encoded frame/sample into one or more RTP packets.
    /// Large frames are automatically fragmented according to MTU constraints.
    ///
    /// # Arguments
    /// * `data` - Encoded media data (codec-specific format)
    ///
    /// # Returns
    /// Vector of RTP packets ready for network transmission. The last packet
    /// in the vector will have the marker bit set to indicate frame boundary.
    fn packetize(&mut self, data: &[u8]) -> Vec<RtpPacket>;

    /// Get the RTP payload type
    ///
    /// Returns the dynamic payload type (typically 96-127 for dynamic mappings)
    /// used in RTP packets generated by this packetizer.
    ///
    /// # Returns
    /// RTP payload type (7-bit value, 0-127)
    fn get_payload_type(&self) -> u8;

    /// Get the Synchronization Source (SSRC) identifier
    ///
    /// Returns the 32-bit SSRC identifier used in RTP packets. This value
    /// uniquely identifies the source of the RTP stream.
    ///
    /// # Returns
    /// SSRC identifier (randomly generated on initialization)
    fn get_ssrc(&self) -> u32;

    /// Get current RTP timestamp
    ///
    /// Returns the current RTP timestamp value. Useful for synchronization
    /// and debugging purposes.
    ///
    /// # Returns
    /// RTP timestamp in 90 kHz clock units (for video)
    fn get_timestamp(&self) -> u32;

    /// Get current RTP sequence number
    ///
    /// Returns the next sequence number that will be used. Useful for
    /// monitoring packet ordering and detecting loss.
    ///
    /// # Returns
    /// 16-bit sequence number (wraps around at 65535)
    fn get_sequence_number(&self) -> u16;
}

/// Trait for RTP depacketization and frame reconstruction
///
/// Implementors of this trait reconstruct encoded media frames from RTP packets,
/// handling fragmentation, reordering, and codec-specific payload formats.
///
/// # Responsibilities
///
/// - Reassemble fragmented frames (e.g., FU-A units in H.264)
/// - Handle packet reordering and loss
/// - Extract codec-specific payloads from RTP packets
/// - Detect frame boundaries using marker bit
pub trait RtpDepacketizer {
    /// Process an RTP packet and attempt frame reconstruction
    ///
    /// Processes a single RTP packet and returns a complete frame if ready.
    /// For fragmented frames, returns `None` until all fragments arrive.
    ///
    /// # Arguments
    /// * `packet` - RTP packet to process
    ///
    /// # Returns
    /// - `Some(Vec<u8>)` - Complete frame ready for decoding (includes start codes for H.264)
    /// - `None` - Frame incomplete, waiting for more fragments
    ///
    /// # Packet Loss Handling
    ///
    /// If packets are lost mid-frame, the next frame start (detected by new timestamp
    /// or start flag) will discard the incomplete buffer and begin fresh reconstruction.
    fn process_packet(&mut self, packet: &RtpPacket) -> Option<Vec<u8>>;

    /// Reset depacketizer state
    ///
    /// Clears all internal buffers and state. Use when:
    /// - Seeking to a new position in the stream
    /// - Recovering from severe packet loss
    /// - Switching between different RTP streams
    ///
    /// After reset, the next processed packet should have a frame start flag.
    fn reset(&mut self);

    /// Check if depacketizer has buffered partial frame data
    ///
    /// Returns `true` if there's an incomplete frame waiting for more packets.
    /// Useful for detecting stalled streams or packet loss.
    ///
    /// # Returns
    /// `true` if partial frame data is buffered, `false` otherwise
    fn has_pending_data(&self) -> bool;
}
